# Common
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
NC='\033[0m'

# Base64 encode a string
function b64() {
    echo -n "$*" | base64
}

function b64decode() {
    echo -n "$*" | base64 --decode
}

# Usage: cht language/something
function cht() {
    curl cht.sh/$*
}

# Recursively delete `.DS_Store` files
# Recursively clear application cache and logss
function cleanup() {
    find . -type f -name '*.DS_Store' -ls -delete
    fd -t d '(cache|log)' ~/dev ~ | grep -E '(app|var)/(cache|log)' | xargs rm -rf
}

# Preview CSVs
function csvpreview() {
    sed 's/,,/, ,/g;s/,,/, ,/g' "$@" | column -s, -t | less -#2 -N -S
}

# Usage: encrypt <string>
# Then, a password is prompted
function encrypt() {
    input=$*
    if [ -z "$input" ]; then
        input=`cat </dev/stdin`
        echo -e "$input"
        echo -e "------------${NC}"
    fi

    result=`echo -n "$input" | openssl enc -e -aes-256-cbc -a`
    lines=`echo -n $result | wc -l`

    if [ ${lines} -ge 10 ]; then
        filename="output.enc"
        echo "$result" > $filename
        echo -e "------------\n${YELLOW}Encrypted output has been stored into following file:${NC}"
        echo -e "$filename"
        echo -e "------------"
        echo -e "${YELLOW}To decrypt the value, use:"
        echo -e "${GREEN}\$${NC} cat \"$filename\" | openssl base64 -d | openssl enc -d -aes-256-cbc"
    else
        echo -e "------------\n${YELLOW}Encrypted output:${NC}"
        echo -e "$result"
        echo -e "------------"
        echo -e "${YELLOW}To decrypt the value, use:"
        echo -e "${GREEN}\$${NC} echo \"$result\" | openssl base64 -d | openssl enc -d -aes-256-cbc"
    fi
}

# Usage: decrypt <string>
# Then, a password is prompted
function decrypt() {
    echo "$*" | openssl base64 -d | openssl enc -d -aes-256-cbc
}

# Usage: encryptfile <filepath> <output> (default: file.gpg)
function encryptfile() {
    output="$1.gpg"

    if [ -n "$2" ]; then
        output="$2"
    fi

    gpg2 --encrypt --recipient vincent --output $output $1
}

# Usage: decryptfile <filepath> <output>
function decryptfile() {
    command="gpg2 --decrypt $1"

    if [ -n "$2" ]; then
        command="$command > $2"
    fi

    eval $command
}

# Clones if a Git repository is given, elsewhere just cd
function cdc() {
    name=`sed -e 's/.*\///g' <<< $1`

    if [[ ! -d "$1" && $1 =~ ^(github|bitbucket|gitlab)\.[a-z]{2,}/.*$ ]]; then
        ssh=`sed -e 's/^/git@/' -e 's/$/.git/' -e 's/\//:/' <<< $1`
        git clone $ssh;
    fi

    cd $name;
}

# Determines size of a file or total size of a directory
function fs() {
    if du -b /dev/null > /dev/null 2>&1; then
        local arg=-sbh;
    else
        local arg=-sh;
    fi
    if [[ -n "$@" ]]; then
        du $arg -- "$@";
    else
        du $arg .[^.]* ./*;
    fi;
}

# Creates a data URL from a file
function dataurl() {
    local mimeType=$(file -b --mime-type "$1");
    if [[ $mimeType == text/* ]]; then
        mimeType="${mimeType};charset=utf-8";
    fi
    echo "data:${mimeType};base64,$(openssl base64 -in "$1" | tr -d '\n')";
}

# Returns useful information using dig tool
function diga() {
    dig +nocmd "$1" any +multiline +noall +answer;
}

# Returns information about usual subdomains
function dig_in_parallel() {
    dig=$(dig +noall +answer $1);

    if [ -n "$dig" ]; then
        echo "âœ” $dig";
    fi
}

function digscan() {
    set +m;

    subdomains=( a ad ads alert alpha adm admin administration amazon ami amis analytics api apis api-gateway app apps application archive archives asset assets auth authentication auto autodiscover aws b back backend bastion bastions berry berrypi beta b2b b2c bill bills black blog bo board brown build builds bus c cache cached cal calendar cdn ceph cli client clients cluster clusters cd ci cloud cms crm com communication connect connection conf config configuration confluence console consul contact contacts content contract contracts corp corporation cpanel cust custom customer customers d dark dashboard data datas database db dbs dev demo demos direct directory discover discovery display dl dns doc documentation domain domains download downloads e elastic elasticsearch elb elk email emails endpoint exchange exchanges ext extern external externals extra extranet f factory free files forum forums front frontend ftp g gw gateway geo git gitlab github go golang gov grafana graph graphs graphana grey green group grpc h ha haproxy health healths help hold holds holder home host hosting http httpproxy https httpsproxy hub hubs i info infos img image images int integ integration intra intranet j jenkins jira k kibana k8s kube kubectl kubernete kubernetes l ldap lib libs library libraries light live lb loadbalancer loader login logs m mail manager market marketing me member members media medias min minio mirror mirrors mobile mobiles monitor monitors monitoring mongo mongodb movie movies my mysql movie movies n nas net network nexus new news no ns1 ns2 ns3 ns4 ns5 o old op operation operations ops open openshift opensource openvpn order orders owa p package packages packagist partner partners perso preprod priv private prive prom prometheus portal postgres postgresql pro prod product production pros prox proxies proxy purple q quality qualys r r7 rabbit rabbitmq rasp raspberry recette red redis reg relay registry remote rest restful restfull rule rules root roots s s3 secret secrets secure sale sales serv server servers sls share shop smtp source sources sql ssh sso sta stage stages staging stat static statistics stats status storage store stream sup support svn t test tests time timeline u upload v vault video videos view views vol vols volume volumes vpn vps w web webdisk webmail white wiki work worker workers www ww1 x y yellow yes z zabix zabbix zoo )

    echo "Checking...\n";

    for subdomain in "${subdomains[@]}"; do
        dig_in_parallel "$subdomain.$1" &
    done

    wait
    set -m;
}

# Transforms a video file to a gif
# Usage: gify <input file> <output file> <start> <duration> [<ratio> <fps>]
function gify {
    ratio=${5:-480:270}
    fpm=${6:-60}

    ffmpeg -i $1 -vf scale=$ratio -r $fpm -ss $3 -t $4 $2
}

# Usage: lighthouse <url> <json | html>
function lighthouse {
    result=`curl -s https://builder-dot-lighthouse-ci.appspot.com/stream\?url=$1\&format=$2 | grep done | cut -d' ' -f3`

    if [[ $2 == "json" ]]; then
        curl -s $result
    else
        echo "Report available: $result"
    fi
}

# Asks the user to select a network interface and returns the result
function selectnetworkinterface() {
    echo "Select the network interface:\n1) Belkin USB-C LAN\n2) Wi-Fi"
    read n

    case $n in
        1) selected="Belkin USB-C LAN";;
        2) selected="Wi-Fi";;
        *) echo "Invalid option"; return;;
    esac
}

# Sets Cloudflare DNS servers on a network interface
function opendns() {
    selectnetworkinterface

    echo "\n-> Setting open DNS servers on network interface '$selected'"
    networksetup -setdnsservers "$selected" 1.1.1.1 1.0.0.1 2606:4700:4700::1111 2606:4700:4700::1001
}

# Sets SSH proxy on a network interface
# Usage: sshproxy <user>@<ip>
# Usage: sshproxy stop
function sshproxy() {
    selectnetworkinterface

    if [[ $1 == "stop" ]]; then
        networksetup -setsocksfirewallproxystate "$selected" off
        ps x | grep "[s]sh -fN -D 5000" | awk '{print $1}' | xargs kill -9
        export http_proxy= https_proxy=

        echo "\n-> Done: proxy is stopped and SSH connection is closed"

        return
    fi

    echo "\n-> Setting socks proxy on network interface '$selected'"

    ssh -fN -D 5000 $1
    networksetup -setsocksfirewallproxy "$selected" localhost 5000
    networksetup -setsocksfirewallproxystate "$selected" on
    export http_proxy=socks5://127.0.0.1:5000 https_proxy=socks5://127.0.0.1:5000

    echo "-> Done: proxy is ready"
}

# Automatically Starting tmux on SSH
function ssht() {
  SSH_HOST="${@: -1}"
  tabname "$SSH_HOST"
  ssh "$@" -t 'tmux ls && exec tmux a || exec tmux new || exec $SHELL -l'
}

# Generates a password and returns hashed values
function genpasswd() {
    passwd=`env LC_CTYPE=C tr -dc 'a-zA-Z0-9-_\$\?' < /dev/urandom | head -c 20`;
    sha256=`echo $passwd | shasum -a 256`;
    sha512=`echo $passwd | shasum -a 512`;
    md5=`md5 -s $passwd | cut -d'=' -f2 | xargs`

    echo "Raw: $passwd\n\nSHA256: $sha256\nSHA512: $sha512\n\nMD5: $md5";
}

# Gets iTunes current track information
function itunes_title_script() {
    osascript -e 'tell application "iTunes" to get the '"$1"' of the current track'
}

function track() {
    artist=$(itunes_title_script artist)
    name=$(itunes_title_script name)

    echo "$artist - $name"
}

# Find files and exec commands at them.
# $ find-exec .coffee cat | wc -l
# # => 9762
function find-exec() {
  find . -type f -iname "*${1:-}*" -exec "${2:-file}" '{}' \;
}

# Count code lines in some directory.
# $ loc py js css
# # => Lines of code for .py: 3781
# # => Lines of code for .js: 3354
# # => Lines of code for .css: 2970
# # => Total lines of code: 10105
function loc() {
  local total
  local firstletter
  local ext
  local lines
  total=0
  for ext in $@; do
    firstletter=$(echo $ext | cut -c1-1)
    if [[ firstletter != "." ]]; then
      ext=".$ext"
    fi
    lines=`find-exec "*$ext" cat | wc -l`
    lines=${lines// /}
    total=$(($total + $lines))
    echo "Lines of code for ${fg[white]}$ext${reset_color}: ${fg[yellow]}$lines${reset_color}"
  done
  echo "${fg[white]}Total${reset_color} lines of code: ${fg[yellow]}$total${reset_color}"
}

# Returns 2FA code
# Usage: otp <service name>
function otp() {
    if [ -z $1 ]; then
        echo
        echo "Usage:"
        echo "   otp google"
        echo
        echo "Configuration: $HOME/.otpkeys"
        echo "Format: name=key"
        return 1;
    fi

    OTPKEY=$(sed -n "s/${1}=//p" ~/.otpkeys)
    if [ -z $OTPKEY ]; then
        echo "$(basename $0): Unknown service name '$1'"
        return 1;
    fi

    oathtool --totp -b $OTPKEY
}

# Uploads a file to transfer.sh and returns the public URL
# Usage: transfer <file>
function transfer() {
    if [ $# -eq 0 ]; then
        echo -e "No arguments specified. Usage:\necho transfer /tmp/test.md\ncat /tmp/test.md | transfer test.md";
        return 1;
    fi

    tmpfile=$( mktemp -t transferXXX );

    if tty -s; then
        basefile=$(basename "$1" | sed -e 's/[^a-zA-Z0-9._-]/-/g');
        curl --progress-bar --upload-file "$1" "https://transfer.sh/$basefile" >> $tmpfile;
    else
        curl --progress-bar --upload-file "-" "https://transfer.sh/$1" >> $tmpfile;
    fi

    cat $tmpfile;
    echo "\n";
    rm -f $tmpfile;
}

# Graph ping between host and a given hostname
# Usage: pinggraph <host>
function pinggraph {
    while true; \
        do echo '{"ping": '`ping -c 1 $1 | awk -F"=| " 'NR==2 {print $10}'`'}'; \
        sleep 0.2; \
    done | \
    jplot --steps 500 ping
}

# Graph (using curl and jplot) website response times
# Usage: wwwgraph <url>
function wwwgraph {
    while true; \
        do curl -s -o /dev/null -w '{"lookup": %{time_namelookup}, "connect": %{time_connect}, "appconnect": %{time_appconnect}, "pretransfer": %{time_pretransfer}, "redirect": %{time_redirect}, "starttransfer": %{time_starttransfer}, "total": %{time_total}}' $1 | \
        sed -E 's/([0-9]),([0-9])/\1.\2/g'; \
        sleep 1.5; \
    done | \
    jplot lookup+connect+appconnect+pretransfer+redirect+starttransfer+total
}

# Graph a process CPU and memory usage
# Usage: processgraph <process name> (Chrome, node, ...)
function processgraph {
    while true; \
        do ps aux | \
        grep -E "$1" | \
        grep -v grep | \
        awk '{ cpu += $3; mem += $4} END {print "{\"cpu\":"cpu",\"mem\":"mem"}"}' | \
        sed -E 's/([0-9]),([0-9])/\1.\2/g'; \
        sleep 0.2; \
    done | \
    jplot --steps 600 cpu+mem
}

# Graph a process CPU and memory usage over SSH
# Usage: sshprocessgraph <host> <process name> (Chrome, node, ...)
function sshprocessgraph {
    subcommand='ps aux | \
        grep -E '\"$2\"' | \
        grep -v grep | \
        awk '\''{ cpu += $3; mem += $4} END {print "{\"cpu\":"cpu",\"mem\":"mem"}"}'\'' | \
        sed -E "s/([0-9]),([0-9])/\1.\2/g"'

    ssh $1 "while true; \
            do $subcommand; \
            sleep 0.2; \
        done" | \
    jplot --steps 600 cpu+mem
}

# Graph a RabbitMQ queue information
# Usage: rabbitgraph <api hostname> <username> <password> <vhost> <queue>
function rabbitgraph {
    while true; \
        do curl -s -u $2:$3 $1/api/queues/$4/$5 | \
        jq -r '.messages_ready //=0 | .messages_unacknowledged //=0 | .messages //=0 | .consumers //=0 | .message_stats.publish_details.rate //=0 | .message_stats.ack_details.rate //=0 | .message_stats.redeliver_details.rate //=0' | \
        jq -r '"{\"ready\":\(.messages_ready), \"unacked\":\(.messages_unacknowledged), \"total\":\(.messages), \"consumers\":\(.consumers), \"publish_rate\":\(.message_stats.publish_details.rate), \"ack_rate\":\(.message_stats.ack_details.rate), \"redeliver_rate\":\(.message_stats.redeliver_details.rate)}"'; \
        sleep 0.3;
    done | \
    jplot --steps 1200 ready+unacked+total+consumers+publish_rate+ack_rate+redeliver_rate
}

# Kubernetes port-forward alias
# Usage: kforward context namespace pod-name ports
function kforward {
    podName=`kubectl get pods -n $2 --context $1 | grep $3 | cut -d' ' -f1`
    kubectl port-forward --context=$1 -n $2 $podName $4
}
