# Common
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
NC='\033[0m'

# Base64 encode a string
function b64() {
    echo -n "$*" | base64
}

function b64decode() {
    echo -n "$*" | base64 --decode
}

# Usage: crypto <money> <currency>
function crypto() {
    curl -s https://api.cryptonator.com/api/ticker/$1-$2 | jq -r '.ticker .price'
}

# Usage: cryptowatch <money> <currency> [<wallet amount> [<alert amount>]]
function cryptowatch() {
    latest=0

    while true; do
        value=$(crypto $1 $2)
        current=`printf "%.2f" $(( value ))`
        date=$(date "+%H:%M:%S")
        operator="${YELLOW}=${NC}"
        walletvalue=0

        # Find operator
        if (( $(echo "$value > $latest" | bc -l) )); then
            operator="${GREEN}⬆${NC}"
        elif (( $(echo "$value < $latest" | bc -l) )); then
            operator="${RED}⬇${NC}"
        fi

        latest=$value

        display="$operator | $date | $1: ${YELLOW}$current${NC}"

        if [ -n "$3" ]; then
            walletvalue=`printf "%.2f" $(( $3 * $value ))`
            display="$display | $2: ${YELLOW}$walletvalue${NC}"
        fi

        echo $display

        # Amount reached? Notify
        if [ -n "$4" ] && (( $(echo "$value >= $4" | bc -l) )); then
            osascript -e "display notification "$value" with title \"Cryptowatch\" subtitle \"Current value:\""
        fi

        sleep 15
    done
}

# Preview CSVs
function csvpreview() {
    sed 's/,,/, ,/g;s/,,/, ,/g' "$@" | column -s, -t | less -#2 -N -S
}

# Usage: encrypt file <output> (default: file.gpg)
function encrypt() {
    output="$1.gpg"

    if [ -n "$2" ]; then
        output="$2"
    fi

    gpg2 --encrypt --recipient vincent --output $output $1
}

# Usage: decrypt file <output>
function decrypt() {
    command="gpg2 --decrypt $1"

    if [ -n "$2" ]; then
        command="$command > $2"
    fi

    eval $command
}

# Clones if a Git repository is given, elsewhere just cd
function cdc() {
    name=`sed -e 's/.*\///g' <<< $1`

    if [[ ! -d "$1" && $1 =~ ^(github|bitbucket|gitlab)\.[a-z]{2,}/.*$ ]]; then
        ssh=`sed -e 's/^/git@/' -e 's/$/.git/' -e 's/\//:/' <<< $1`
        git clone $ssh;
    fi

    cd $name;
}

# Determines size of a file or total size of a directory
function fs() {
    if du -b /dev/null > /dev/null 2>&1; then
        local arg=-sbh;
    else
        local arg=-sh;
    fi
    if [[ -n "$@" ]]; then
        du $arg -- "$@";
    else
        du $arg .[^.]* ./*;
    fi;
}

# Creates a data URL from a file
function dataurl() {
    local mimeType=$(file -b --mime-type "$1");
    if [[ $mimeType == text/* ]]; then
        mimeType="${mimeType};charset=utf-8";
    fi
    echo "data:${mimeType};base64,$(openssl base64 -in "$1" | tr -d '\n')";
}

# Returns useful information using dig tool
function diga() {
    dig +nocmd "$1" any +multiline +noall +answer;
}

# Returns information about usual subdomains
function dig_in_parallel() {
    dig=$(dig +noall +answer $1);

    if [ -n "$dig" ]; then
        echo "✔ $dig";
    fi
}

function digscan() {
    set +m;

    subdomains=( a ad ads alert alpha adm admin administration analytics api apis api-gateway app apps application assets auth authentication auto autodiscover b back backend beta b2b b2c black blog bo board brown build builds c cache cached cal calendar cdn ceph cli client clients cluster clusters cd ci cloud cms crm conf config configuration console consul contact contacts content contract contracts corp corporation cpanel cust custom customer customers d dark dashboard database db dev demo demos direct directory discover display dl dns doc documentation domain domains download downloads e elasticsearch elb elk endpoint exchange exchanges ext extern external externals extra extranet f factory free files front frontend ftp g gateway geo git gitlab github go golang grafana graph graphs grey green group h ha haproxy health healths help home host hosting hub hubs i info infos int integ integration intra intranet j jenkins jira k kibana k8s kube kubectl kubernetes l light live lb loadbalancer loader logs m mail manager market marketing minio mobile monitor monitoring mongo mongodb movie movies mysql movie movies n nas nexus new news no ns1 ns2 ns3 ns4 ns5 o old open openshift opensource order orders owa p package packages packagist partner partners perso preprod priv private prive portal postgres postgresql pro pros purple q quality qualys r r7 recette red redis reg relay registry remote rule rules root roots s s3 secret secrets secure sale sales serv server servers share shop smtp source sources ssh sso staging stat static statistics stats status storage store stream support svn t test tests time timeline u upload v vault video videos view views vol vols volume volumes vpn w web webdisk webmail white wiki work worker workers www x y yellow yes z zoo )

    echo "Checking...\n";

    for subdomain in "${subdomains[@]}"; do
        dig_in_parallel "$subdomain.$1" &
    done

    wait
    set -m;
}

# Transforms a video file to a gif
# Usage: gify <input file> <output file> <start> <duration> [<ratio> <fps>]
function gify {
    ratio=${5:-480:270}
    fpm=${6:-60}

    ffmpeg -i $1 -vf scale=$ratio -r $fpm -ss $3 -t $4 $2
}

# Usage: lighthouse <url> <json | html>
function lighthouse {
    result=`curl -s https://builder-dot-lighthouse-ci.appspot.com/stream\?url=$1\&format=$2 | grep done | cut -d' ' -f3`

    if [[ $2 == "json" ]]; then
        curl -s $result
    else
        echo "Report available: $result"
    fi
}

# Asks the user to select a network interface and returns the result
function selectnetworkinterface() {
    echo "Select the network interface:\n1) Belkin USB-C LAN\n2) Wi-Fi"
    read n

    case $n in
        1) selected="Belkin USB-C LAN";;
        2) selected="Wi-Fi";;
        *) echo "Invalid option"; return;;
    esac
}

# Sets Cloudflare DNS servers on a network interface
function opendns() {
    selectnetworkinterface

    echo "\n-> Setting open DNS servers on network interface '$selected'"
    networksetup -setdnsservers "$selected" 1.1.1.1 1.0.0.1
}

# Sets SSH proxy on a network interface
# Usage: sshproxy <user>@<ip>
# Usage: sshproxy stop
function sshproxy() {
    selectnetworkinterface

    if [[ $1 == "stop" ]]; then
        networksetup -setsocksfirewallproxystate "$selected" off
        ps x | grep "[s]sh -fN -D 5000" | awk '{print $1}' | xargs kill -9
        export http_proxy= https_proxy=

        echo "\n-> Done: proxy is stopped and SSH connection is closed"

        return
    fi

    echo "\n-> Setting socks proxy on network interface '$selected'"

    ssh -fN -D 5000 $1
    networksetup -setsocksfirewallproxy "$selected" localhost 5000
    networksetup -setsocksfirewallproxystate "$selected" on
    export http_proxy=socks5://127.0.0.1:5000 https_proxy=socks5://127.0.0.1:5000

    echo "-> Done: proxy is ready"
}

# Automatically Starting tmux on SSH
function ssht() {
  SSH_HOST="${@: -1}"
  tabname "$SSH_HOST"
  ssh "$@" -t 'tmux ls && exec tmux a || exec tmux new || exec $SHELL -l'
}

# Generates a password and returns hashed values
function genpasswd() {
    passwd=`env LC_CTYPE=C tr -dc 'a-zA-Z0-9-_\$\?' < /dev/urandom | head -c 20`;
    sha256=`echo $passwd | shasum -a 256`;
    sha512=`echo $passwd | shasum -a 512`;
    md5=`md5 -s $passwd | cut -d'=' -f2 | xargs`

    echo "Raw: $passwd\n\nSHA256: $sha256\nSHA512: $sha512\n\nMD5: $md5";
}

# Gets iTunes current track information
function itunes_title_script() {
    osascript -e 'tell application "iTunes" to get the '"$1"' of the current track'
}

function track() {
    artist=$(itunes_title_script artist)
    name=$(itunes_title_script name)

    echo "$artist - $name"
}

# Find files and exec commands at them.
# $ find-exec .coffee cat | wc -l
# # => 9762
function find-exec() {
  find . -type f -iname "*${1:-}*" -exec "${2:-file}" '{}' \;
}

# Count code lines in some directory.
# $ loc py js css
# # => Lines of code for .py: 3781
# # => Lines of code for .js: 3354
# # => Lines of code for .css: 2970
# # => Total lines of code: 10105
function loc() {
  local total
  local firstletter
  local ext
  local lines
  total=0
  for ext in $@; do
    firstletter=$(echo $ext | cut -c1-1)
    if [[ firstletter != "." ]]; then
      ext=".$ext"
    fi
    lines=`find-exec "*$ext" cat | wc -l`
    lines=${lines// /}
    total=$(($total + $lines))
    echo "Lines of code for ${fg[white]}$ext${reset_color}: ${fg[yellow]}$lines${reset_color}"
  done
  echo "${fg[white]}Total${reset_color} lines of code: ${fg[yellow]}$total${reset_color}"
}

# Uploads a file to transfer.sh and returns the public URL
# Usage: transfer <file>
function transfer() {
    if [ $# -eq 0 ]; then
        echo -e "No arguments specified. Usage:\necho transfer /tmp/test.md\ncat /tmp/test.md | transfer test.md";
        return 1;
    fi

    tmpfile=$( mktemp -t transferXXX );

    if tty -s; then
        basefile=$(basename "$1" | sed -e 's/[^a-zA-Z0-9._-]/-/g');
        curl --progress-bar --upload-file "$1" "https://transfer.sh/$basefile" >> $tmpfile;
    else
        curl --progress-bar --upload-file "-" "https://transfer.sh/$1" >> $tmpfile;
    fi

    cat $tmpfile;
    echo "\n";
    rm -f $tmpfile;
}

# Graph ping between host and a given hostname
# Usage: pinggraph <host>
function pinggraph {
    while true; \
        do echo '{"ping": '`ping -c 1 $1 | awk -F"=| " 'NR==2 {print $10}'`'}'; \
        sleep 0.2; \
    done | \
    jplot --steps 500 ping
}

# Graph (using curl and jplot) website response times
# Usage: wwwgraph <url>
function wwwgraph {
    while true; \
        do curl -s -o /dev/null -w '{"lookup": %{time_namelookup}, "connect": %{time_connect}, "appconnect": %{time_appconnect}, "pretransfer": %{time_pretransfer}, "redirect": %{time_redirect}, "starttransfer": %{time_starttransfer}, "total": %{time_total}}' $1 | \
        sed -E 's/([0-9]),([0-9])/\1.\2/g'; \
        sleep 1.5; \
    done | \
    jplot lookup+connect+appconnect+pretransfer+redirect+starttransfer+total
}

# Graph a process CPU and memory usage
# Usage: processgraph <process name> (Chrome, node, ...)
function processgraph {
    while true; \
        do ps aux | \
        grep -E "$1" | \
        grep -v grep | \
        awk '{ cpu += $3; mem += $4} END {print "{\"cpu\":"cpu",\"mem\":"mem"}"}' | \
        sed -E 's/([0-9]),([0-9])/\1.\2/g'; \
        sleep 0.2; \
    done | \
    jplot --steps 600 cpu+mem
}

# Graph a process CPU and memory usage over SSH
# Usage: sshprocessgraph <host> <process name> (Chrome, node, ...)
function sshprocessgraph {
    subcommand='ps aux | \
        grep -E '\"$2\"' | \
        grep -v grep | \
        awk '\''{ cpu += $3; mem += $4} END {print "{\"cpu\":"cpu",\"mem\":"mem"}"}'\'' | \
        sed -E "s/([0-9]),([0-9])/\1.\2/g"'

    ssh $1 "while true; \
            do $subcommand; \
            sleep 0.2; \
        done" | \
    jplot --steps 600 cpu+mem
}

# Graph a RabbitMQ queue information
# Usage: rabbitgraph <api hostname> <username> <password> <vhost> <queue>
function rabbitgraph {
    while true; \
        do curl -s -u $2:$3 $1/api/queues/$4/$5 | \
        jq -r '.messages_ready //=0 | .messages_unacknowledged //=0 | .messages //=0 | .consumers //=0 | .message_stats.publish_details.rate //=0 | .message_stats.ack_details.rate //=0 | .message_stats.redeliver_details.rate //=0' | \
        jq -r '"{\"ready\":\(.messages_ready), \"unacked\":\(.messages_unacknowledged), \"total\":\(.messages), \"consumers\":\(.consumers), \"publish_rate\":\(.message_stats.publish_details.rate), \"ack_rate\":\(.message_stats.ack_details.rate), \"redeliver_rate\":\(.message_stats.redeliver_details.rate)}"'; \
        sleep 0.3;
    done | \
    jplot --steps 1200 ready+unacked+total+consumers+publish_rate+ack_rate+redeliver_rate
}
